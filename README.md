# ITP125FinalProject

This is the final brute force password cracking practice
This project in written in visual studio
The python environment is Python 3.7 (64-bit)
The script is written is python 3
libraries used: hashlib, time, itertools


Analysis:
Apparently the longer the password is, the longer it takes to crack the passwords
The first three passwords are easy to crack. the fourth one took like 2 minutes, and the fifth one took approximately 200 seconds to crack
Performance in screenshot included

Yes there is a way that I can make the code faster. I can utiliza multiprocessing in the code.
The program takes a long time to process mainly because there are way too many permutations for any password longer than length 5,
so maybe for any password longer than length 5, first generate head characters of length 4, and get remaining characters by subtracting the set of head characters from charset
and use multiprocessing.pool() to generate the rest of the permutations

What's more, for practical purposes, we should also keep a dictionary of already generated hashes. Because in real life, we don't know the length of the password based on MD5
hashes. When we want to crack a password, we first check the goal hash with the dictionary generated by the past cracking effort of ours, if there is a hit, we have the answer.
If there isn't, extend the guess password length, and generate permutations. Add the newly generated MD5 hashes to the dictionary. 
This approach might take up lots of memory space. And the speed might not be significantly improved. Don't know if it's worth it.

Another way of multiprocessing is that we could run separate thread/ process on different goal hashes. For example, we can have 6 process concurrrently running if we have 6 passwords.
However, this way can be pretty wasteful, and the ideal way of multiprocessing should be implemeneted on multiprocessing the permutations like the first step mentioned above.
